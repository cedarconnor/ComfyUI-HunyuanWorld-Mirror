<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ComfyUI 3D Viewer - Gaussian Splats & Point Clouds</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="info">
        <h1>ComfyUI 3D Viewer</h1>
        <div id="file-info">Loading...</div>
        <div id="controls-info">
            <strong>Controls:</strong><br>
            • Left-click + drag: Rotate<br>
            • Right-click + drag: Pan<br>
            • Scroll: Zoom<br>
            • Press F: Flip 180°
        </div>
        <div id="settings">
            <label>
                Point Size: <input type="range" id="pointSize" min="0.001" max="0.1" step="0.001" value="0.01">
                <span id="pointSizeValue">0.01</span>
            </label>
            <br>
            <label>
                Decimation: <input type="range" id="decimation" min="1" max="20" step="1" value="1">
                <span id="decimationValue">1x (all points)</span>
            </label>
            <br>
            <label>
                Distance Clip: <input type="range" id="distanceClip" min="0" max="100" step="1" value="100">
                <span id="distanceClipValue">Off</span>
            </label>
            <br>
            <label>
                <input type="checkbox" id="autoRotate"> Auto Rotate
            </label>
            <br>
            <button id="flip180" style="margin-top: 10px; padding: 5px 10px; cursor: pointer;">Flip 180°</button>
        </div>
    </div>

    <div id="loading">
        <div class="spinner"></div>
        <p>Loading 3D data...</p>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';

        // Get URL parameters
        const params = new URLSearchParams(window.location.search);
        const filePath = params.get('file');
        const mode = params.get('mode') || 'pointcloud';

        if (!filePath) {
            document.getElementById('loading').innerHTML = '<p style="color: red;">Error: No file specified. Use ?file=path/to/file.ply</p>';
            throw new Error('No file path provided');
        }

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.01,
            1000
        );
        camera.position.set(2, 2, 2);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: false
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = true;
        controls.minDistance = 0.1;
        controls.maxDistance = 100;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Grid helper
        const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
        scene.add(gridHelper);

        // Axes helper
        const axesHelper = new THREE.AxesHelper(1);
        scene.add(axesHelper);

        // Global reference to points material for controls
        let pointsMaterial = null;
        let pointsObject = null;
        let originalGeometry = null;  // Store original geometry for decimation
        let currentDecimation = 1;  // Current decimation factor
        let currentDistanceClip = 100;  // Current distance clip percentage (100 = no clipping)
        let maxDistance = 1.0;  // Max distance from center (set after loading)

        // Load PLY file
        const loader = new PLYLoader();
        const loadingDiv = document.getElementById('loading');
        const fileInfoDiv = document.getElementById('file-info');

        // Convert file path for web access
        // If it's an absolute path, we need to serve it through our server
        const fileUrl = `/file?path=${encodeURIComponent(filePath)}`;

        // Function to load shader file
        async function loadShader(url) {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Failed to load shader: ${url}`);
            return await response.text();
        }

        loader.load(
            fileUrl,
            async (geometry) => {
                loadingDiv.style.display = 'none';

                // Compute normals if not present
                if (!geometry.attributes.normal) {
                    geometry.computeVertexNormals();
                }

                // Check if this is a Gaussian splat file
                const isGaussianSplat = mode === 'splat' && (
                    geometry.attributes.scale_0 &&
                    geometry.attributes.rot_0 &&
                    geometry.attributes.opacity
                );

                // SPLAT RENDERING PATH
                if (isGaussianSplat) {
                    console.log('Rendering as Gaussian Splats');

                    // Load shaders
                    let vertexShader, fragmentShader;
                    try {
                        [vertexShader, fragmentShader] = await Promise.all([
                            loadShader('splat.vert'),
                            loadShader('splat.frag')
                        ]);
                    } catch (error) {
                        console.error('Failed to load splat shaders:', error);
                        alert('Error loading splat shaders. Falling back to point cloud rendering.');
                        // Fall through to point cloud rendering
                    }

                    if (vertexShader && fragmentShader) {
                        // Parse Gaussian attributes from PLY
                        const numGaussians = geometry.attributes.position.count;

                        // Extract instance attributes
                        const centers = geometry.attributes.position.array;
                        const scales = new Float32Array(numGaussians * 3);
                        const rotations = new Float32Array(numGaussians * 4);
                        const opacities = new Float32Array(numGaussians);
                        const colors = new Float32Array(numGaussians * 3);

                        // Read scales
                        for (let i = 0; i < numGaussians; i++) {
                            scales[i * 3 + 0] = geometry.attributes.scale_0.array[i];
                            scales[i * 3 + 1] = geometry.attributes.scale_1.array[i];
                            scales[i * 3 + 2] = geometry.attributes.scale_2.array[i];
                        }

                        // Read rotations (quaternion wxyz)
                        for (let i = 0; i < numGaussians; i++) {
                            rotations[i * 4 + 0] = geometry.attributes.rot_0.array[i]; // w
                            rotations[i * 4 + 1] = geometry.attributes.rot_1.array[i]; // x
                            rotations[i * 4 + 2] = geometry.attributes.rot_2.array[i]; // y
                            rotations[i * 4 + 3] = geometry.attributes.rot_3.array[i]; // z
                        }

                        // Read opacities
                        for (let i = 0; i < numGaussians; i++) {
                            opacities[i] = geometry.attributes.opacity.array[i];
                        }

                        // Read colors (from f_dc_* or color attribute)
                        if (geometry.attributes.f_dc_0) {
                            for (let i = 0; i < numGaussians; i++) {
                                colors[i * 3 + 0] = geometry.attributes.f_dc_0.array[i];
                                colors[i * 3 + 1] = geometry.attributes.f_dc_1.array[i];
                                colors[i * 3 + 2] = geometry.attributes.f_dc_2.array[i];
                            }
                        } else if (geometry.attributes.color) {
                            colors.set(geometry.attributes.color.array);
                        }

                        // Flip Y-axis and center
                        geometry.scale(1, -1, 1);
                        geometry.computeBoundingBox();
                        const center = new THREE.Vector3();
                        geometry.boundingBox.getCenter(center);
                        geometry.translate(-center.x, -center.y, -center.z);

                        // Create instanced quad geometry
                        const quadGeometry = new THREE.BufferGeometry();
                        const quadPositions = new Float32Array([
                            -1, -1,
                             1, -1,
                            -1,  1,
                             1,  1
                        ]);
                        const quadIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
                        quadGeometry.setAttribute('position', new THREE.BufferAttribute(quadPositions, 2));
                        quadGeometry.setIndex(new THREE.BufferAttribute(quadIndices, 1));

                        // Add instance attributes
                        quadGeometry.setAttribute('center', new THREE.InstancedBufferAttribute(centers, 3));
                        quadGeometry.setAttribute('scale', new THREE.InstancedBufferAttribute(scales, 3));
                        quadGeometry.setAttribute('rotation', new THREE.InstancedBufferAttribute(rotations, 4));
                        quadGeometry.setAttribute('opacity', new THREE.InstancedBufferAttribute(opacities, 1));
                        quadGeometry.setAttribute('color', new THREE.InstancedBufferAttribute(colors, 3));

                        // Create shader material
                        const splatMaterial = new THREE.RawShaderMaterial({
                            vertexShader: vertexShader,
                            fragmentShader: fragmentShader,
                            uniforms: {
                                projectionMatrix: { value: camera.projectionMatrix },
                                modelViewMatrix: { value: new THREE.Matrix4() },
                                viewport: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                                scale_modifier: { value: 1.0 }
                            },
                            transparent: true,
                            depthTest: true,
                            depthWrite: false,
                            blending: THREE.NormalBlending
                        });

                        // Create mesh
                        const splatMesh = new THREE.Mesh(quadGeometry, splatMaterial);
                        scene.add(splatMesh);
                        pointsObject = splatMesh; // Store reference for controls

                        // Update uniforms on render
                        const originalRender = renderer.render.bind(renderer);
                        renderer.render = function(scene, camera) {
                            if (splatMaterial.uniforms) {
                                splatMaterial.uniforms.modelViewMatrix.value.multiplyMatrices(
                                    camera.matrixWorldInverse,
                                    splatMesh.matrixWorld
                                );
                                splatMaterial.uniforms.viewport.value.set(window.innerWidth, window.innerHeight);
                            }
                            originalRender(scene, camera);
                        };

                        // Update file info
                        const boundingBox = geometry.boundingBox;
                        const size = new THREE.Vector3();
                        boundingBox.getSize(size);
                        const maxDim = Math.max(size.x, size.y, size.z);

                        fileInfoDiv.innerHTML = `
                            <strong>File:</strong> ${filePath.split('/').pop()}<br>
                            <strong>Mode:</strong> Gaussian Splats<br>
                            <strong>Gaussians:</strong> ${numGaussians.toLocaleString()}<br>
                            <strong>Size:</strong> ${maxDim.toFixed(2)} units
                        `;

                        // Adjust camera
                        const dist = maxDim * 2;
                        camera.position.set(dist, dist * 0.5, dist);
                        camera.lookAt(0, 0, 0);
                        controls.update();

                        console.log('Loaded Gaussian Splats:', {
                            gaussians: numGaussians,
                            bounds: size
                        });

                        return; // Skip point cloud rendering
                    }
                }

                // POINT CLOUD RENDERING PATH (fallback)
                // Check for color attributes
                // PLY files can have 'color', 'red/green/blue', or no colors
                let hasColors = false;
                if (geometry.attributes.color) {
                    hasColors = true;

                    // Fix color contrast issue in splat mode
                    // Gaussian splat colors are often in linear space and need gamma correction
                    if (mode === 'splat') {
                        const colors = geometry.attributes.color;
                        const count = colors.count;

                        // Apply gamma correction: linear to sRGB (gamma ≈ 2.2)
                        for (let i = 0; i < count * 3; i++) {
                            const linearValue = colors.array[i];
                            // Use sRGB transfer function
                            const sRGBValue = linearValue <= 0.0031308
                                ? 12.92 * linearValue
                                : 1.055 * Math.pow(linearValue, 1.0 / 2.4) - 0.055;
                            colors.array[i] = Math.max(0, Math.min(1, sRGBValue));
                        }
                        colors.needsUpdate = true;
                    }
                } else {
                    // PLYLoader might store colors differently, check for RGB components
                    // Some PLY files store as separate red/green/blue attributes
                    console.log('Geometry attributes:', Object.keys(geometry.attributes));
                }

                // Flip Y-axis to correct upside-down orientation
                // (Convert from vision coordinate system to graphics coordinate system)
                geometry.scale(1, -1, 1);

                // Center geometry
                geometry.computeBoundingBox();
                const center = new THREE.Vector3();
                geometry.boundingBox.getCenter(center);
                geometry.translate(-center.x, -center.y, -center.z);

                // Determine point size based on mode and geometry bounds
                const boundingBox = geometry.boundingBox;
                const size = new THREE.Vector3();
                boundingBox.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z);

                const basePointSize = mode === 'splat' ? maxDim * 0.005 : maxDim * 0.002;

                // Create material based on mode
                pointsMaterial = new THREE.PointsMaterial({
                    size: basePointSize,
                    vertexColors: hasColors,
                    sizeAttenuation: true,
                    transparent: mode === 'splat',
                    opacity: mode === 'splat' ? 0.8 : 1.0,
                    alphaTest: 0.01
                });

                // If no vertex colors, use a default color
                if (!hasColors) {
                    pointsMaterial.color = new THREE.Color(0x00aaff);
                    console.warn('No color attributes found in PLY file, using default blue color');
                }

                // Store original geometry for decimation and clipping
                originalGeometry = geometry.clone();

                // Calculate max distance from center for distance clipping
                const positions = geometry.attributes.position.array;
                maxDistance = 0;
                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i];
                    const y = positions[i + 1];
                    const z = positions[i + 2];
                    const dist = Math.sqrt(x * x + y * y + z * z);
                    if (dist > maxDistance) maxDistance = dist;
                }

                // Create points
                pointsObject = new THREE.Points(geometry, pointsMaterial);
                scene.add(pointsObject);

                // Update file info
                const vertexCount = geometry.attributes.position.count;
                const hasNormals = geometry.attributes.normal !== undefined;
                const hasColorsText = hasColors ? 'Yes' : 'No';
                const hasNormalsText = hasNormals ? 'Yes' : 'No';

                fileInfoDiv.innerHTML = `
                    <strong>File:</strong> ${filePath.split('/').pop()}<br>
                    <strong>Mode:</strong> ${mode}<br>
                    <strong>Points:</strong> ${vertexCount.toLocaleString()}<br>
                    <strong>Colors:</strong> ${hasColorsText}<br>
                    <strong>Normals:</strong> ${hasNormalsText}<br>
                    <strong>Size:</strong> ${maxDim.toFixed(2)} units
                `;

                // Update point size control
                const pointSizeSlider = document.getElementById('pointSize');
                pointSizeSlider.value = basePointSize;
                pointSizeSlider.min = basePointSize * 0.1;
                pointSizeSlider.max = basePointSize * 10;
                pointSizeSlider.step = basePointSize * 0.1;
                document.getElementById('pointSizeValue').textContent = basePointSize.toFixed(4);

                // Adjust camera position based on model size
                const dist = maxDim * 2;
                camera.position.set(dist, dist * 0.5, dist);
                camera.lookAt(0, 0, 0);
                controls.update();

                console.log('Loaded 3D data:', {
                    vertices: vertexCount,
                    hasColors,
                    hasNormals,
                    bounds: size
                });
            },
            (progress) => {
                const percent = (progress.loaded / progress.total * 100).toFixed(0);
                loadingDiv.innerHTML = `
                    <div class="spinner"></div>
                    <p>Loading 3D data... ${percent}%</p>
                `;
            },
            (error) => {
                loadingDiv.innerHTML = `<p style="color: #ff4444;">Error loading file:<br>${error.message}</p>`;
                console.error('Error loading PLY file:', error);
            }
        );

        // Function to apply decimation and distance clipping
        function applyFilters() {
            if (!originalGeometry || !pointsObject) {
                return;
            }

            const positions = originalGeometry.attributes.position.array;
            const colors = originalGeometry.attributes.color ? originalGeometry.attributes.color.array : null;
            const normals = originalGeometry.attributes.normal ? originalGeometry.attributes.normal.array : null;

            const filteredPositions = [];
            const filteredColors = colors ? [] : null;
            const filteredNormals = normals ? [] : null;

            // Calculate distance threshold
            const distanceThreshold = (currentDistanceClip / 100) * maxDistance;

            // Apply both decimation and distance clipping
            for (let i = 0; i < positions.length / 3; i++) {
                // Apply decimation
                if (i % currentDecimation !== 0) continue;

                // Apply distance clipping
                const x = positions[i * 3];
                const y = positions[i * 3 + 1];
                const z = positions[i * 3 + 2];
                const dist = Math.sqrt(x * x + y * y + z * z);

                if (dist <= distanceThreshold) {
                    filteredPositions.push(x, y, z);
                    if (colors) {
                        filteredColors.push(colors[i * 3], colors[i * 3 + 1], colors[i * 3 + 2]);
                    }
                    if (normals) {
                        filteredNormals.push(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);
                    }
                }
            }

            // Create new geometry with filtered data
            const newGeometry = new THREE.BufferGeometry();
            newGeometry.setAttribute('position', new THREE.Float32BufferAttribute(filteredPositions, 3));
            if (filteredColors) {
                newGeometry.setAttribute('color', new THREE.Float32BufferAttribute(filteredColors, 3));
            }
            if (filteredNormals) {
                newGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(filteredNormals, 3));
            }

            // Replace geometry in points object
            const oldGeometry = pointsObject.geometry;
            pointsObject.geometry = newGeometry;
            oldGeometry.dispose(); // Free memory

            console.log(`Filtered: ${positions.length / 3} → ${filteredPositions.length / 3} points (decimation=${currentDecimation}x, distance=${currentDistanceClip}%)`);
        }

        // Point size control
        document.getElementById('pointSize').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            if (pointsMaterial) {
                pointsMaterial.size = value;
                pointsMaterial.needsUpdate = true;
            }
            document.getElementById('pointSizeValue').textContent = value.toFixed(4);
        });

        // Decimation control
        document.getElementById('decimation').addEventListener('input', (e) => {
            currentDecimation = parseInt(e.target.value);

            if (!originalGeometry) return;

            // Update label
            const totalPoints = originalGeometry.attributes.position.count;
            const estimatedPoints = Math.floor(totalPoints / currentDecimation * (currentDistanceClip / 100));
            document.getElementById('decimationValue').textContent =
                currentDecimation === 1 ? '1x (all points)' : `${currentDecimation}x (~${(estimatedPoints / 1000000).toFixed(1)}M points)`;

            // Apply filters
            applyFilters();
        });

        // Distance clip control
        document.getElementById('distanceClip').addEventListener('input', (e) => {
            currentDistanceClip = parseInt(e.target.value);

            if (!originalGeometry) return;

            // Update label
            document.getElementById('distanceClipValue').textContent =
                currentDistanceClip === 100 ? 'Off' : `${currentDistanceClip}% (${(maxDistance * currentDistanceClip / 100).toFixed(2)} units)`;

            // Apply filters
            applyFilters();
        });

        // Auto-rotate control
        document.getElementById('autoRotate').addEventListener('change', (e) => {
            controls.autoRotate = e.target.checked;
            controls.autoRotateSpeed = 2.0;
        });

        // Flip 180 degrees button
        document.getElementById('flip180').addEventListener('click', () => {
            if (pointsObject) {
                pointsObject.rotation.y += Math.PI;
                console.log('Flipped 180 degrees');
            }
        });

        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'g':
                    gridHelper.visible = !gridHelper.visible;
                    break;
                case 'a':
                    axesHelper.visible = !axesHelper.visible;
                    break;
                case 'r':
                    controls.reset();
                    break;
                case 'f':
                    if (pointsObject) {
                        pointsObject.rotation.y += Math.PI;
                        console.log('Flipped 180 degrees');
                    }
                    break;
                case 'h':
                    document.getElementById('info').style.display =
                        document.getElementById('info').style.display === 'none' ? 'block' : 'none';
                    break;
            }
        });

        console.log('ComfyUI 3D Viewer initialized');
        console.log('Keyboard shortcuts: G=toggle grid, A=toggle axes, F=flip 180°, R=reset view, H=toggle UI');
    </script>
</body>
</html>
